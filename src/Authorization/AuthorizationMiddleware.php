<?php

declare(strict_types=1);

namespace ORB\Authorization;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class AuthorizationMiddleware implements MiddlewareInterface
{

    private function refresh(string $access, string $refresh) : array {
        $encodedAccessToken = '';
        if ($encodedAccessToken === $refresh){

        }
    }


    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        /*
         * Получает запрос
         * Взапросе передаются два токена refresh и access
         * Данный мидлвар расшифровывает access токен
         * Если токен не расшифровывается, тоесть устарел или подмененна сигнатура, мидлвар отправляет оба токена
         * в метод этого мидлвара refresh
         *
         * Метод рефрешь проводит валидацию связи между access и refresh токенами, если все ок то
         * лезет в БД, где проверяет пришел ли от пользователя тот же самый рефреш токен, что и хранится
         * в БД. Если нет. То мидлвар отправляет пользователя заного проходить авторизацию на страницу /login
         * Если токен который пришел от пользователя, тот же что и в БД, значит метод refresh возвращает два токена
         * access и refresh и позволяет запросу пройти дальше по цепочке. На обратном пути цепочки мидлвар добавляет в
         * response новую пару токенов. Refresh обновляется в cookie, а access записывается в переменную приложения
         *
         * Допустим украли access токен, хз как если он храниться в памяти приложения.
         * Злоумышленник пользуется этим токеном до тех пор пока он кончится или не потеряется путем обновления страницы
         *
         * Допустим украли refresh токен и перешли на страницу /refresh, хотя при такой системе обновление токена не имеет
         * своего эндпоинта и оно делается внутри мидлвара.
         * Зашли на /refresh передали токен. Для защиты надо передавать два токена на refresh метод или на эндпоинт
         * потому как refresh токен сгенерирован алгоритмом на основе access токена и таким образом привязан к нему.
         * ------------------------------------------------------------------------------------------------------------
         * Пример:
         * access token:
         * eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. - Заголовок
         * eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ. - Payload
         * SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c - Signature
         * ------------------------------------------------------------------------------------------------------------
         * refresh token: нужен алгоритм который будет гененировать этот токен связанным с access токеном так
         * чтобы патом можно было проверить их связку!
         * Например берется первая, третья, последний символ заголовка, вторая, пятая, одиннадцатая буква payload
         * первые три, последние два и четвертый и седьмой символ сигнатуры. Выглядит новый refresh так:
         * eJ9ydISfl5cKR. Зачем так?
         * Первый вариант был клеить uuid4 и сигнатуру access токена через точку по такому виду:
         * uuid4.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c. Но так нельзя. Потому как заполучив один рефреш токен
         * злоумышленник может передать в метод взамен access токена вот такое:
         * eyAAAAAAA.eyBBB.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c и метод завалидирует потому как будет
         * валидация по сигнатуре которая палится как раз в refresh токене.
         * В случае с алгоритмом, злоумышленник может тоже конечно же подобрать необходимый access токен,
         * но для этого ему необходим алгоритм генерации refresh'а. Плюс подхода в том, что алгоритм можно легко менять
         * хоть раз в неделю, хоть раз в час, он будет браться как инструкция из папки Algorithm. Можно алгоритм
         * даймоном менять каждый час или пол часа на сервере, тогда во вновь выданных парах access и refresh, второй
         * токен всегда будет непредсказуем, а соответсвенно нельзя будет придумать или подобрать access токен в качестве
         * первого параметра
         *
         * Они выдаются только парой и поэтому не может быть рефреша не связанного с access
         * Метод рефреш сначала проверяет связь токенов, если злоумышленник не украл сразу два токена
         * то и сравнивать будет не с чем, система выкинет ошибку ибо в метод нужно две переменных передавать.
         * Даже если было передано две переменных один access токен, второй refresh, то идет сверка по сигнатуре
         * Если сигнатуры совпали, далее идет запрос в БД на обновление этой пары, если исгнатуры не совпали так как
         * hash сигнатуры access токена попробуй угадай, идет перенаправление на /login
         * По сути эта сверка нужна для защиты от кражи одного токена, нужно красть пару ибо необходима сверка связи.
         *
         * Допустим украли два токена и передают суда. Злоумышленник может пользоваться доступом до тех пор
         * пока не будет устаревш access токен, как только он устареет, система сама проведет обновление токенов
         * методом указанным в пункте выше, и оригинального пользователя выкинет на страницу /login
         * так как украденный refresh токен хоть и пройдет первичную проверку на связь с украденным access токеном,
         * новый refresh токен будет записан в БД. В это время происходит окончание токена у оригинала (у злоумышленника
         * он икончаются одновременно ведь это одни и те же токены, но допустим оригинал отошел на пять минут от компа)
         * эта пара выдавалась вместе, но refresh токен (старый получается уже, так как злоумышленник обновил токены)
         * оригинала не пройдет проверку в БД, так как злоумышленником будет получена
         * новая пара токенов и оригиналу придется перелогиниваться
         */
        $secretKey = 'Secret Key';
        $accessToken = '';
        $refreshToken = '';
        if(!$payload = JWT::decode($accessToken,new Key($secretKey, 'HS256'))) {
            $this->refresh($accessToken, $refreshToken);
        }
    }
}